# -*- coding: utf-8 -*-
"""spotifyapp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mfblxzPUSDusSfc6l1zafZ7HAO9zO-DY
"""

import streamlit as st
import pandas as pd
import json
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from xgboost import XGBClassifier
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt

st.set_page_config(page_title="ğŸµ Song Recommender", layout="centered")
st.title("ğŸµ Enhanced Spotify Song Recommendation System")

@st.cache_data
def load_spotify_data():
    df = pd.read_csv("spotify_tracks.csv")
    df = df.dropna()
    return df

spotify_df = load_spotify_data()

# Main feature list
model_features = ['danceability', 'energy', 'loudness', 'speechiness', 'acousticness',
                  'instrumentalness', 'liveness', 'tempo', 'duration_ms', 'valence']

# Remove exact duplicates (based on song name + artist if available)
spotify_df = spotify_df.drop_duplicates(subset=['track_name', 'track_genre'], keep='first')

# ML model evaluation section
st.subheader("ğŸ“Š Model Evaluation")

X = spotify_df[model_features[:-1]]
y = spotify_df['valence'].apply(lambda x: 1 if x > 0.5 else 0)

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

# Store reports
reports = {}

# KNN
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(X_train, y_train)
reports["KNN"] = classification_report(y_test, knn.predict(X_test))

# Random Forest
rf = RandomForestClassifier()
rf.fit(X_train, y_train)
reports["Random Forest"] = classification_report(y_test, rf.predict(X_test))

# Logistic Regression
logreg = LogisticRegression(max_iter=1000)
logreg.fit(X_train, y_train)
reports["Logistic Regression"] = classification_report(y_test, logreg.predict(X_test))

# SVM
svm = SVC()
svm.fit(X_train, y_train)
reports["SVM"] = classification_report(y_test, svm.predict(X_test))

# XGBoost
xgb = XGBClassifier(use_label_encoder=False, eval_metric='logloss')
xgb.fit(X_train, y_train)
reports["XGBoost"] = classification_report(y_test, xgb.predict(X_test))

# Display results
model_to_view = st.selectbox("ğŸ“ˆ Select a model to view its classification report", list(reports.keys()))
st.text(reports[model_to_view])

# Upload playlist
uploaded_file = st.file_uploader("ğŸ“‚ Upload your liked songs playlist (.json)", type="json")

if uploaded_file:
    playlist_data = json.load(uploaded_file)
    playlist_df = pd.DataFrame(playlist_data)

    available_features = [f for f in model_features[:-1] if f in playlist_df.columns]
    if not available_features:
        st.error("ğŸš« Playlist missing required features.")
    else:
        playlist_df = playlist_df.dropna(subset=available_features)
        user_profile_vector = playlist_df[available_features].mean().values.reshape(1, -1)

        scaler_subset = StandardScaler()
        scaler_subset.fit(spotify_df[available_features])
        user_scaled = scaler_subset.transform(user_profile_vector)

        # Filter options
        filter_type = st.radio("ğŸ” Apply a filter?", ["None", "By Genre", "By Mood"])
        filtered_df = spotify_df.copy()

        if filter_type == "By Genre":
            genres = spotify_df['track_genre'].dropna().unique().tolist()
            selected_genre = st.selectbox("ğŸ¼ Select Genre", sorted(genres))
            filtered_df = filtered_df[filtered_df['track_genre'].str.contains(selected_genre, case=False, na=False)]

        elif filter_type == "By Mood":
            mood = st.selectbox("ğŸ§ Select Mood", ["Energetic + Happy", "Calm + Low Valence"])
            if mood == "Energetic + Happy":
                filtered_df = filtered_df[(filtered_df['energy'] > 0.7) & (filtered_df['valence'] > 0.7)]
            else:
                filtered_df = filtered_df[(filtered_df['energy'] < 0.4) & (filtered_df['valence'] < 0.4)]

        if not filtered_df.empty:
            df_scaled = scaler_subset.transform(filtered_df[available_features])
            similarity = cosine_similarity(user_scaled, df_scaled)[0]
            filtered_df = filtered_df.copy()
            filtered_df['similarity'] = similarity

            # Sort and shuffle within high-similarity group
            top_df = filtered_df.sort_values(by='similarity', ascending=False).head(50)
            top_df = top_df.drop_duplicates(subset=['track_name', 'track_genre'])
            top_df = top_df.sample(n=min(10, len(top_df)), random_state=42)

            st.subheader("ğŸ¯ Diverse Recommendations Just for You")
            st.dataframe(top_df[['track_name', 'track_genre', 'similarity']])
        else:
            st.warning("âš ï¸ No songs match your filter.")

        # Optional: PCA Plot
        if st.checkbox("Show PCA Visualization"):
            pca = PCA(n_components=2)
            X_reduced = pca.fit_transform(X_scaled)
            pca_df = pd.DataFrame(X_reduced, columns=["PC1", "PC2"])
            pca_df["liked"] = y.values

            fig, ax = plt.subplots()
            scatter = ax.scatter(pca_df["PC1"], pca_df["PC2"], c=pca_df["liked"], cmap="coolwarm", alpha=0.6)
            ax.set_title("PCA of Spotify Songs")
            ax.set_xlabel("PC1")
            ax.set_ylabel("PC2")
            st.pyplot(fig)
else:
    st.info("ğŸ‘ˆ Upload your liked songs playlist to get recommendations.")

